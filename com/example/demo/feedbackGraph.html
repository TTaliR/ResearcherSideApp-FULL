<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Sensor Feedback Over Time</title>
  <script src="https://d3js.org/d3.v7.min.js"></script>
  <style>
    /* Page-level styling */
    body {
      font-family: sans-serif;
      margin: 0;
      padding: 20px;
    }

    h2 {
      text-align: center;
      margin-bottom: 10px;
    }

    /* Tooltip: floating info box shown on hover */
.tooltip {
  position: absolute;
  background: rgba(255, 255, 255, 0.95);
  border: 1px solid #888;
  border-radius: 6px;
  padding: 10px;
  box-shadow: 0px 2px 8px rgba(0,0,0,0.2);
  font-size: 13px;
  line-height: 1.4;
  pointer-events: none;
  opacity: 0;
  transition: opacity 0.3s ease, transform 0.3s ease;
  transform: translateY(-10px);
}

    .legend {
      font-size: 12px;
    }

    /* The svg will size to the viewport container */
    svg {
      width: 100%;
      height: 600px;
    }

    /* Modern axis/grid styles */
    .axis path,
    .axis line {
      stroke: #333;
      stroke-width: 1.5px;
      shape-rendering: crispEdges;
    }

    .axis text {
      fill: #333;
      font-size: 13px;
      font-family: sans-serif;
    }

    .grid line {
      stroke: #ddd;
      stroke-opacity: 0.7;
      shape-rendering: crispEdges;
    }

    .grid path {
      stroke: none;
    }
  </style>
</head>
<body>
  <h2>Sensor Feedback Over Time</h2>
  <!-- meta-info: shows which user and sensor the chart is for -->
  <h3 id="meta-info" style="text-align:center; margin-top: 0; font-weight: normal; color: #555;"></h3>

  <!-- main drawing surface -->
  <svg></svg>

  <!-- tooltip element updated by JS on hover -->
  <div class="tooltip"></div>

  <script>
/*
  DATA_PLACEHOLDER -> replaced by the server/runtime with an array of objects
  Each data item expected shape (example):
    { time: "2023-01-01T12:00:00.000Z", value: 42, intensity: 120, pulses: 4, alert_type: "...", duration: 200, interval: 50 }
  USER_ID_PLACEHOLDER -> replaced with numeric/string user id
  SENSOR_TYPE_PLACEHOLDER -> replaced with string describing sensor
*/
const data = DATA_PLACEHOLDER;


console.log(data.map(d => d.time));

    // Basic meta values injected by runtime
    const userId = USER_ID_PLACEHOLDER; //
    const sensorType = SENSOR_TYPE_PLACEHOLDER;

    // Show basic context for the chart
    document.getElementById("meta-info").textContent = `User ID: ${userId} | Sensor: ${sensorType}`;

    // Parse timestamps from ISO string to Date objects (UTC)
const parseTime = d3.utcParse("%Y-%m-%dT%H:%M:%S.%LZ");
const formatTime = d3.timeFormat("%Y-%m-%d %H:%M");
    data.forEach(d => d.parsedTime = parseTime(d.time));

    // Prepare SVG + margins and compute inner drawing width/height
    const svg = d3.select("svg");
const margin = { top: 40, right: 200, bottom: 60, left: 100 };
    const width = svg.node().clientWidth - margin.left - margin.right;
    const height = svg.node().clientHeight - margin.top - margin.bottom;

    // Clip path prevents drawing outside axes area (important for zoom/pan)
svg.append("defs").append("clipPath")
  .attr("id", "clip")
  .append("rect")
  .attr("x", 0)
  .attr("y", 0)
  .attr("width", width)
  .attr("height", height);

// Main container group translated by margins
const g = svg.append("g")
  .attr("transform", `translate(${margin.left},${margin.top})`);

// dataLayer is clipped so only line/circles are clipped (axes/legend are outside)
const dataLayer = g.append("g")
  .attr("clip-path", "url(#clip)");


    // X scale (time) and Y scale (value)
    const x = d3.scaleTime()
      .domain(d3.extent(data, d => d.parsedTime))
      .range([20, width]);

    const y = d3.scaleLinear()
    .domain([
        (() => {
            const minVal = d3.min(data, d => d.value);
            return minVal === 0 ? 0 : minVal - 10; // pad lower bound (unless zero)
        })(),
        d3.max(data, d => d.value) + 10 // add top padding
    ])
    .nice()
    .range([height, 0]);

    // Color mapping for intensity using thresholds
    const intensityThresholds = [20, 50, 100, 150, 200, 230, 255];
    const intensityColors = [
      "#fceabb",  // 0–20 → very light yellow
      "#f8c156",  // 21–50 → light orange
      "#f59e42",  // 51–100 → orange
      "#ec5e34",  // 101–150 → red-orange
      "#cd2e3a",  // 151–200 → red
      "#8e063b",  // 201–230 → dark red
      "#3b0a45"   // 231–255 → very dark purple
    ];
    const color = d3.scaleThreshold()
      .domain(intensityThresholds)
      .range(intensityColors);

    // Circle radius maps to pulses count (visual weight)
    const maxPulses = d3.max(data, d => d.pulses || 0) || 1;
    const radius = d3.scaleSqrt()
    .domain([0, maxPulses])
    .range([4, 14]);

    const tooltip = d3.select(".tooltip");

    // X axis group (kept separate so zoom can update easily)
const xAxis = d3.axisBottom(x).ticks(6).tickFormat(formatTime);

const xAxisG = g.append("g")
  .attr("class", "axis x-axis")
  .attr("transform", `translate(0,${height})`)
  .call(xAxis);

    // Y axis + gridlines
    g.append("g")
      .attr("class", "axis y-axis grid")
      .call(
        d3.axisLeft(y)
          .ticks(6)
          .tickSize(-width)
      );

    // Line generator (monotone curve for smoothness)
    const line = d3.line()
      .x(d => x(d.parsedTime))
      .y(d => y(d.value))
      .curve(d3.curveMonotoneX);

    // Group time-series points into per-minute buckets to avoid overplotting
    // reducedData will contain one representative per minute (preferentially an alert)
    // Filter to only include points with pulses > 0
    const filteredData = data.filter(d => d.pulses > 0);
    const bucketedData = d3.groups(filteredData, d => d3.timeMinute(d.parsedTime));
    const reducedData = bucketedData.map(([minute, group]) =>
      group.find(d => d.alert_type) || group[0]
    );

    // Draw animated path for the full data (smooth curve)
const linePath = dataLayer.append("path")
      .datum(data)
      .attr("fill", "none")
      .attr("stroke", "#4682B4")
      .attr("stroke-width", 2)
      .attr("d", line);

    // Animate stroke drawing for visual polish
    const totalLength = linePath.node().getTotalLength();

    linePath
      .attr("stroke-dasharray", totalLength + " " + totalLength)
      .attr("stroke-dashoffset", totalLength)
      .transition()
      .duration(2000)
      .ease(d3.easeLinear)
      .attr("stroke-dashoffset", 0);

    // Draw feedback circles only for points marked as alerts
    // Animated grow-in and staggered delays for clarity
dataLayer.selectAll("circle")
      .data(reducedData.filter(d => d.alert_type))
      .enter().append("circle")
      .attr("cx", d => x(d.parsedTime))
      .attr("cy", d => y(d.value))
      .attr("r", 0)
      .attr("fill", d => color(d.intensity))
      .attr("stroke", "#333")
      .attr("opacity", 0)
      .transition()
      .duration(1000)
      .delay((d, i) => i * 250)
      .attr("r", d => radius(d.pulses))
      .attr("opacity", 1);

    // Re-select circles to add interactive hover handlers (tooltip + scale up)
dataLayer.selectAll("circle")
      .on("mouseover", function (event, d) {
        // Show tooltip with key details; position near cursor
        tooltip
        .style("transform", "translateY(-10px)")
        .transition()
        .duration(200)
        .style("opacity", 1)
        .style("transform", "translateY(0px)");
    tooltip.html(
            `<strong>Time:</strong> ${formatTime(d.parsedTime)}<br>
            <strong>Value:</strong> ${d.value}<br>
            <strong>Intensity:</strong> ${d.intensity}<br>
            <strong>Pulses:</strong> ${d.pulses}<br>
            <strong>Duration:</strong> ${d.duration || 0} ms<br>
            <strong>Interval:</strong> ${d.interval || 0} ms`
        )
          .style("left", (event.pageX + 10) + "px")
          .style("top", (event.pageY - 30) + "px");

        // Highlight hovered circle (gentle scale)
        d3.select(this)
          .transition()
          .duration(150)
          .attr("r", radius(d.pulses) * 1.3);
      })
      .on("mouseout", function (event, d) {
        // Hide tooltip and restore circle radius
        tooltip.transition().duration(200).style("opacity", 0);
        d3.select(this)
          .transition()
          .duration(200)
        .attr("r", radius(d.pulses));
      });

    // Legend: explain color (intensity) and size (pulses)
    const legend = svg.append("g")
      .attr("class", "legend")
      .attr("transform", `translate(${width + margin.left + 20},${margin.top})`);

    legend.append("text").text("Intensity (Color)").attr("font-weight", "bold");

    // Render intensity legend entries (threshold ranges)
    const legendThresholds = [0, ...intensityThresholds];
    legendThresholds.forEach((v, i) => {
      if (i < intensityColors.length) {
        const rangeEnd = intensityThresholds[i] ?? 255;
        const rangeLabel = `${v}–${rangeEnd}`;

        legend.append("rect")
          .attr("x", 0)
          .attr("y", 20 + i * 14)
          .attr("width", 20)
          .attr("height", 12)
          .attr("fill", intensityColors[i]);

        legend.append("text")
          .attr("x", 30)
          .attr("y", 30 + i * 14)
          .attr("font-size", "11px")
          .text(rangeLabel);
      }
    });

    // Pulses size legend: demonstrates mapping from count -> circle radius
    legend.append("text").text("Pulses (Size)").attr("y", 130).attr("font-weight", "bold");
const pulseValues = [2, 4, 6, 8, 10];
let currentY = 150; // starting y-position for pulse legend entries
const pulsePadding = 6; // gap between legend circles
pulseValues.forEach((v, i) => {
  const r = radius(v);

  legend.append("circle")
    .attr("cx", 10)
    .attr("cy", currentY + r)
    .attr("r", r)
    .attr("fill", "#999");

  legend.append("text")
    .attr("x", 30)
    .attr("y", currentY + r + 4) // text slightly below circle center
    .text(v);

  currentY += 2 * r + pulsePadding; // move down for next circle
});

    // Zoom behavior: allows pan + zoom on x-axis while keeping y fixed
const zoom = d3.zoom()
  .scaleExtent([1, 100]) // min/max zoom scales
  .translateExtent([[0, 0], [width, height]]) // allowed panning bounds
  .extent([[0, 0], [width, height]])
  .on("zoom", zoomed);

svg.call(zoom);

// Prevent automatic zoom on double-click (optional UX preference)
svg.on("dblclick.zoom", null);

// Called on zoom/pan events. Updates x-axis, line path, and circle x positions.
function zoomed(event) {
  const transform = event.transform;
  const zx = transform.rescaleX(x);

  // Update the X axis with the transformed scale
  xAxisG.call(xAxis.scale(zx));

  // Recompute the line path using the rescaled x
  const lineWithZoom = d3.line()
    .x(d => zx(d.parsedTime))
    .y(d => y(d.value))
    .curve(d3.curveMonotoneX);

  linePath.datum(data).attr("d", lineWithZoom);

  // Move circles horizontally according to zoom/pan
  dataLayer.selectAll("circle")
    .attr("cx", d => zx(d.parsedTime));
}
  </script>
</body>
</html>
