<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Sensor Feedback Over Time</title>
  <script src="https://d3js.org/d3.v7.min.js"></script>
  <style>
    /* Page-level styling */
    body {
      font-family: sans-serif;
      margin: 0;
      padding: 20px;
    }

    h2 {
      text-align: center;
      margin-bottom: 10px;
    }

    /* Tooltip: floating info box shown on hover */
.tooltip {
  position: absolute;
  background: rgba(255, 255, 255, 0.95);
  border: 1px solid #888;
  border-radius: 6px;
  padding: 10px;
  box-shadow: 0px 2px 8px rgba(0,0,0,0.2);
  font-size: 13px;
  line-height: 1.4;
  pointer-events: none;
  opacity: 0;
  transition: opacity 0.3s ease, transform 0.3s ease;
  transform: translateY(-10px);
}

    .legend {
      font-size: 12px;
    }

    /* The svg will size to the viewport container */
    svg {
      width: 100%;
      height: 650px;
    }

    /* Modern axis/grid styles */
    .axis path,
    .axis line {
      stroke: #333;
      stroke-width: 1.5px;
      shape-rendering: crispEdges;
    }

    .axis text {
      fill: #333;
      font-size: 13px;
      font-family: sans-serif;
    }

    .grid line {
      stroke: #ddd;
      stroke-opacity: 0.7;
      shape-rendering: crispEdges;
    }

    .grid path {
      stroke: none;
    }

    /* Rotated x-axis labels to prevent overlap */
    .x-axis text {
      text-anchor: end;
      transform: rotate(-45deg);
      transform-origin: center;
    }

    /* No data message styling */
    .no-alerts-message {
      text-anchor: middle;
      fill: #666;
      font-size: 16px;
      font-style: italic;
    }

    /* Zoom hint styling */
    .zoom-hint {
      text-align: center;
      color: #888;
      font-size: 12px;
      margin-top: 5px;
    }

    /* Export button styling */
    .export-btn {
      display: block;
      margin: 10px auto;
      padding: 10px 20px;
      background-color: #4682B4;
      color: white;
      border: none;
      border-radius: 6px;
      font-size: 14px;
      cursor: pointer;
      transition: background-color 0.2s ease, transform 0.1s ease;
    }

    .export-btn:hover {
      background-color: #3a6d96;
      transform: translateY(-1px);
    }

    .export-btn:active {
      transform: translateY(0);
    }

    .export-btn:disabled {
      background-color: #aaa;
      cursor: not-allowed;
      transform: none;
    }
  </style>
</head>
<body>
  <h2>Sensor Feedback Over Time</h2>
  <!-- meta-info: shows which user and sensor the chart is for -->
  <h3 id="meta-info" style="text-align:center; margin-top: 0; font-weight: normal; color: #555;"></h3>

  <!-- data stats info -->
  <p id="data-stats" style="text-align:center; margin: 5px 0; font-size: 13px; color: #777;"></p>

  <!-- zoom hint for users -->
  <p class="zoom-hint">Tip: Use mouse scroll to zoom in/out on the timeline, drag to pan</p>

  <!-- Export button -->
  <button id="exportBtn" class="export-btn">Save as PNG</button>

  <!-- main drawing surface -->
  <svg></svg>

  <!-- tooltip element updated by JS on hover -->
  <div class="tooltip"></div>

  <script>
/*
  DATA_PLACEHOLDER -> replaced by the server/runtime with an array of objects
  Each data item expected shape (example):
    { time: "2023-01-01T12:00:00.000Z", value: 42, intensity: 120, pulses: 4, alert_type: "...", duration: 200, interval: 50 }
  USER_ID_PLACEHOLDER -> replaced with numeric/string user id
  SENSOR_TYPE_PLACEHOLDER -> replaced with string describing sensor
*/
const data = DATA_PLACEHOLDER;


console.log(data.map(d => d.time));

    // Basic meta values injected by runtime
    const userId = USER_ID_PLACEHOLDER; //
    const sensorType = SENSOR_TYPE_PLACEHOLDER;

    // Show basic context for the chart
    document.getElementById("meta-info").textContent = `User ID: ${userId} | Sensor: ${sensorType}`;

    // Parse timestamps from ISO string to Date objects (UTC)
const parseTime = d3.utcParse("%Y-%m-%dT%H:%M:%S.%LZ");
const formatTime = d3.timeFormat("%Y-%m-%d %H:%M");

// Multi-scale time formatter - adapts to zoom level
const multiFormat = (date) => {
  if (d3.timeSecond(date) < date) return d3.timeFormat(".%L")(date);
  if (d3.timeMinute(date) < date) return d3.timeFormat(":%S")(date);
  if (d3.timeHour(date) < date) return d3.timeFormat("%H:%M")(date);
  if (d3.timeDay(date) < date) return d3.timeFormat("%H:%M")(date);
  if (d3.timeMonth(date) < date) return d3.timeFormat("%b %d")(date);
  if (d3.timeYear(date) < date) return d3.timeFormat("%B")(date);
  return d3.timeFormat("%Y")(date);
};

    data.forEach(d => d.parsedTime = parseTime(d.time));

    // Prepare SVG + margins and compute inner drawing width/height
    const svg = d3.select("svg");
const margin = { top: 40, right: 200, bottom: 100, left: 100 };
    const width = svg.node().clientWidth - margin.left - margin.right;
    const height = svg.node().clientHeight - margin.top - margin.bottom;

    // Clip path prevents drawing outside axes area (important for zoom/pan)
svg.append("defs").append("clipPath")
  .attr("id", "clip")
  .append("rect")
  .attr("x", 0)
  .attr("y", 0)
  .attr("width", width)
  .attr("height", height);

// Main container group translated by margins
const g = svg.append("g")
  .attr("transform", `translate(${margin.left},${margin.top})`);

// dataLayer is clipped so only line/circles are clipped (axes/legend are outside)
const dataLayer = g.append("g")
  .attr("clip-path", "url(#clip)");


    // X scale (time) and Y scale (value)
    const x = d3.scaleTime()
      .domain(d3.extent(data, d => d.parsedTime))
      .range([0, width]);

    const y = d3.scaleLinear()
    .domain([
        (() => {
            const minVal = d3.min(data, d => d.value);
            return minVal === 0 ? 0 : minVal - 10; // pad lower bound (unless zero)
        })(),
        d3.max(data, d => d.value) + 10 // add top padding
    ])
    .nice()
    .range([height, 0]);

    // Color mapping for intensity using thresholds
    const intensityThresholds = [20, 50, 100, 150, 200, 230, 255];
    const intensityColors = [
      "#fceabb",  // 0–20 → very light yellow
      "#f8c156",  // 21–50 → light orange
      "#f59e42",  // 51–100 → orange
      "#ec5e34",  // 101–150 → red-orange
      "#cd2e3a",  // 151–200 → red
      "#8e063b",  // 201–230 → dark red
      "#3b0a45"   // 231–255 → very dark purple
    ];
    const color = d3.scaleThreshold()
      .domain(intensityThresholds)
      .range(intensityColors);

    // Circle radius maps to pulses count (visual weight)
    const maxPulses = d3.max(data, d => d.pulses || 0) || 1;
    const radius = d3.scaleSqrt()
    .domain([0, maxPulses])
    .range([4, 14]);

    const tooltip = d3.select(".tooltip");

    // Calculate appropriate number of ticks based on width
    const tickCount = Math.max(4, Math.min(10, Math.floor(width / 120)));

    // X axis group with adaptive formatting
const xAxis = d3.axisBottom(x)
  .ticks(tickCount)
  .tickFormat(multiFormat);

const xAxisG = g.append("g")
  .attr("class", "axis x-axis")
  .attr("transform", `translate(0,${height})`)
  .call(xAxis);

// Rotate x-axis labels to prevent overlap
xAxisG.selectAll("text")
  .attr("transform", "rotate(-45)")
  .style("text-anchor", "end")
  .attr("dx", "-0.8em")
  .attr("dy", "0.15em");

// Show data statistics
const alertCount = data.filter(d => d.alert_type).length;
const timeRange = d3.extent(data, d => d.parsedTime);
const statsText = `${data.length} data points | ${alertCount} alerts | ` +
  `Range: ${d3.timeFormat("%b %d, %Y")(timeRange[0])} – ${d3.timeFormat("%b %d, %Y")(timeRange[1])}`;
document.getElementById("data-stats").textContent = statsText;

    // Y axis + gridlines
    g.append("g")
      .attr("class", "axis y-axis grid")
      .call(
        d3.axisLeft(y)
          .ticks(6)
          .tickSize(-width)
      );

    // Line generator (monotone curve for smoothness)
    const line = d3.line()
      .x(d => x(d.parsedTime))
      .y(d => y(d.value))
      .curve(d3.curveMonotoneX);

    // Group time-series points into per-minute buckets to avoid overplotting
    // reducedData will contain one representative per minute (preferentially an alert)
    // Filter to only include points with pulses > 0
    const filteredData = data.filter(d => d.pulses > 0);
    const bucketedData = d3.groups(filteredData, d => d3.timeMinute(d.parsedTime));
    const reducedData = bucketedData.map(([minute, group]) =>
      group.find(d => d.alert_type) || group[0]
    );

    // Draw animated path for the full data (smooth curve)
const linePath = dataLayer.append("path")
      .datum(data)
      .attr("fill", "none")
      .attr("stroke", "#4682B4")
      .attr("stroke-width", 2)
      .attr("d", line);

    // Animate stroke drawing for visual polish
    const totalLength = linePath.node().getTotalLength();

    linePath
      .attr("stroke-dasharray", totalLength + " " + totalLength)
      .attr("stroke-dashoffset", totalLength)
      .transition()
      .duration(2000)
      .ease(d3.easeLinear)
      .attr("stroke-dashoffset", 0);

    // Draw feedback circles only for points marked as alerts
    // Animated grow-in and staggered delays for clarity
dataLayer.selectAll("circle")
      .data(reducedData.filter(d => d.alert_type))
      .enter().append("circle")
      .attr("cx", d => x(d.parsedTime))
      .attr("cy", d => y(d.value))
      .attr("r", 0)
      .attr("fill", d => color(d.intensity))
      .attr("stroke", "#333")
      .attr("opacity", 0)
      .transition()
      .duration(1000)
      .delay((d, i) => i * 250)
      .attr("r", d => radius(d.pulses))
      .attr("opacity", 1);

    // Re-select circles to add interactive hover handlers (tooltip + scale up)
dataLayer.selectAll("circle")
      .on("mouseover", function (event, d) {
        // Calculate tooltip position with edge-awareness
        const tooltipWidth = 180;
        const tooltipHeight = 120;
        const viewportWidth = window.innerWidth;
        const viewportHeight = window.innerHeight;

        let leftPos = event.pageX + 15;
        let topPos = event.pageY - 30;

        // Flip to left side if too close to right edge
        if (leftPos + tooltipWidth > viewportWidth - 20) {
          leftPos = event.pageX - tooltipWidth - 15;
        }
        // Flip below if too close to top
        if (topPos < 10) {
          topPos = event.pageY + 20;
        }
        // Adjust if too close to bottom
        if (topPos + tooltipHeight > viewportHeight - 10) {
          topPos = viewportHeight - tooltipHeight - 10;
        }

        // Show tooltip with key details
        tooltip
        .style("transform", "translateY(-10px)")
        .transition()
        .duration(200)
        .style("opacity", 1)
        .style("transform", "translateY(0px)");
    tooltip.html(
            `<strong>Time:</strong> ${formatTime(d.parsedTime)}<br>
            <strong>Value:</strong> ${d.value}<br>
            <strong>Intensity:</strong> ${d.intensity}<br>
            <strong>Pulses:</strong> ${d.pulses}<br>
            <strong>Duration:</strong> ${d.duration || 0} ms<br>
            <strong>Interval:</strong> ${d.interval || 0} ms`
        )
          .style("left", leftPos + "px")
          .style("top", topPos + "px");

        // Highlight hovered circle (gentle scale)
        d3.select(this)
          .transition()
          .duration(150)
          .attr("r", radius(d.pulses) * 1.3);
      })
      .on("mouseout", function (event, d) {
        // Hide tooltip and restore circle radius
        tooltip.transition().duration(200).style("opacity", 0);
        d3.select(this)
          .transition()
          .duration(200)
        .attr("r", radius(d.pulses));
      });

    // Show message if data exists but no alerts to display
    const alertsToShow = reducedData.filter(d => d.alert_type);
    if (data.length > 0 && alertsToShow.length === 0) {
      dataLayer.append("text")
        .attr("class", "no-alerts-message")
        .attr("x", width / 2)
        .attr("y", height / 2)
        .text("No feedback alerts in this time range. Only the data line is shown.");
    }

    // Legend: explain color (intensity) and size (pulses)
    const legend = svg.append("g")
      .attr("class", "legend")
      .attr("transform", `translate(${width + margin.left + 20},${margin.top})`);

    legend.append("text").text("Intensity (Color)").attr("font-weight", "bold");

    // Render intensity legend entries (threshold ranges)
    const legendThresholds = [0, ...intensityThresholds];
    legendThresholds.forEach((v, i) => {
      if (i < intensityColors.length) {
        const rangeEnd = intensityThresholds[i] ?? 255;
        const rangeLabel = `${v}–${rangeEnd}`;

        legend.append("rect")
          .attr("x", 0)
          .attr("y", 20 + i * 14)
          .attr("width", 20)
          .attr("height", 12)
          .attr("fill", intensityColors[i]);

        legend.append("text")
          .attr("x", 30)
          .attr("y", 30 + i * 14)
          .attr("font-size", "11px")
          .text(rangeLabel);
      }
    });

    // Pulses size legend: demonstrates mapping from count -> circle radius
    legend.append("text").text("Pulses (Size)").attr("y", 130).attr("font-weight", "bold");
const pulseValues = [2, 4, 6, 8, 10];
let currentY = 150; // starting y-position for pulse legend entries
const pulsePadding = 6; // gap between legend circles
pulseValues.forEach((v, i) => {
  const r = radius(v);

  legend.append("circle")
    .attr("cx", 10)
    .attr("cy", currentY + r)
    .attr("r", r)
    .attr("fill", "#999");

  legend.append("text")
    .attr("x", 30)
    .attr("y", currentY + r + 4) // text slightly below circle center
    .text(v);

  currentY += 2 * r + pulsePadding; // move down for next circle
});

    // Zoom behavior: allows pan + zoom on x-axis while keeping y fixed
const zoom = d3.zoom()
  .scaleExtent([1, 100]) // min/max zoom scales
  .translateExtent([[-width, 0], [2 * width, height]]) // allow panning beyond initial bounds
  .extent([[0, 0], [width, height]])
  .on("zoom", zoomed);

svg.call(zoom);

// Prevent automatic zoom on double-click (optional UX preference)
svg.on("dblclick.zoom", null);

// Called on zoom/pan events. Updates x-axis, line path, and circle x positions.
function zoomed(event) {
  const transform = event.transform;
  const zx = transform.rescaleX(x);

  // Update the X axis with the transformed scale and adaptive formatting
  const zoomedTickCount = Math.max(4, Math.min(12, Math.floor(width / 100)));
  xAxisG.call(d3.axisBottom(zx).ticks(zoomedTickCount).tickFormat(multiFormat));

  // Re-apply rotation to x-axis labels after zoom update
  xAxisG.selectAll("text")
    .attr("transform", "rotate(-45)")
    .style("text-anchor", "end")
    .attr("dx", "-0.8em")
    .attr("dy", "0.15em");

  // Recompute the line path using the rescaled x
  const lineWithZoom = d3.line()
    .x(d => zx(d.parsedTime))
    .y(d => y(d.value))
    .curve(d3.curveMonotoneX);

  // Remove the stroke-dasharray animation when zooming to prevent line disappearing
  linePath
    .attr("stroke-dasharray", null)
    .attr("stroke-dashoffset", null)
    .datum(data)
    .attr("d", lineWithZoom);

  // Move circles horizontally according to zoom/pan
  dataLayer.selectAll("circle")
    .attr("cx", d => zx(d.parsedTime));
}

// ==================== EXPORT TO PNG ====================
/**
 * Exports the current SVG chart to a PNG image file.
 * Opens a new window with the image and instructions to save it.
 */
function exportToPng() {
  const exportBtn = document.getElementById('exportBtn');
  const originalText = exportBtn.textContent;

  // Show loading state
  exportBtn.disabled = true;
  exportBtn.textContent = 'Generating...';

  try {
    const svgElement = document.querySelector('svg');
    const svgRect = svgElement.getBoundingClientRect();

    // Clone SVG to avoid modifying the original
    const svgClone = svgElement.cloneNode(true);

    // Set explicit dimensions on the clone
    svgClone.setAttribute('width', svgRect.width);
    svgClone.setAttribute('height', svgRect.height);

    // Add white background to SVG
    const bgRect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
    bgRect.setAttribute('width', '100%');
    bgRect.setAttribute('height', '100%');
    bgRect.setAttribute('fill', 'white');
    svgClone.insertBefore(bgRect, svgClone.firstChild);

    // Serialize SVG to string
    const serializer = new XMLSerializer();
    let svgString = serializer.serializeToString(svgClone);

    // Encode SVG for use in image source
    const svgBlob = new Blob([svgString], { type: 'image/svg+xml;charset=utf-8' });
    const url = URL.createObjectURL(svgBlob);

    // Create canvas and draw SVG onto it
    const canvas = document.createElement('canvas');
    const scale = 2; // Higher resolution for better quality
    canvas.width = svgRect.width * scale;
    canvas.height = svgRect.height * scale;

    const ctx = canvas.getContext('2d');
    ctx.scale(scale, scale);
    ctx.fillStyle = 'white';
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    const img = new Image();

    img.onload = function() {
      ctx.drawImage(img, 0, 0);
      URL.revokeObjectURL(url);

      // Generate filename with timestamp
      const now = new Date();
      const timestamp = now.toISOString().slice(0, 19).replace(/[:-]/g, '');
      const filename = `sensor_chart_user${userId}_${sensorType}_${timestamp}.png`;

      // Get base64 data URL
      const dataUrl = canvas.toDataURL('image/png');

      // Call Java bridge to save file (JavaFX WebView)
      if (typeof javaExportBridge !== 'undefined' && javaExportBridge !== null) {
        try {
          javaExportBridge.saveImage(dataUrl, filename);
        } catch (e) {
          console.error('Java bridge error:', e);
          alert('Export failed. Please try again.');
        }
      } else {
        // Fallback: show alert with instructions
        alert('Export not available. The Java export bridge is not initialized.');
      }

      exportBtn.disabled = false;
      exportBtn.textContent = originalText;
    };

    img.onerror = function() {
      console.error('Failed to load SVG for export');
      URL.revokeObjectURL(url);
      exportBtn.disabled = false;
      exportBtn.textContent = 'Export failed - try again';
      setTimeout(() => {
        exportBtn.textContent = originalText;
      }, 2000);
    };

    img.src = url;

  } catch (error) {
    console.error('Export error:', error);
    exportBtn.disabled = false;
    exportBtn.textContent = 'Export failed';
    setTimeout(() => {
      exportBtn.textContent = originalText;
    }, 2000);
  }
}

// Attach export button click handler
document.getElementById('exportBtn').addEventListener('click', exportToPng);
  </script>
</body>
</html>
