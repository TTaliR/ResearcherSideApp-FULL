<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Sensor Feedback Over Time</title>
  <script src="https://d3js.org/d3.v7.min.js"></script>
  <style>
    body {
      font-family: sans-serif;
      margin: 0;
      padding: 20px;
    }

    h2 {
      text-align: center;
      margin-bottom: 10px;
    }
.tooltip {
  position: absolute;
  background: rgba(255, 255, 255, 0.95);
  border: 1px solid #888;
  border-radius: 6px;
  padding: 10px;
  box-shadow: 0px 2px 8px rgba(0,0,0,0.2);
  font-size: 13px;
  line-height: 1.4;
  pointer-events: none;
  opacity: 0;
  transition: opacity 0.3s ease, transform 0.3s ease;
  transform: translateY(-10px);
}

    .legend {
      font-size: 12px;
    }

    svg {
      width: 100%;
      height: 600px;
    }

    /* ✨ Modern axis styles */
    .axis path,
    .axis line {
      stroke: #333;
      stroke-width: 1.5px;
      shape-rendering: crispEdges;
    }

    .axis text {
      fill: #333;
      font-size: 13px;
      font-family: sans-serif;
    }

    .grid line {
      stroke: #ddd;
      stroke-opacity: 0.7;
      shape-rendering: crispEdges;
    }

    .grid path {
      stroke: none;
    }
  </style>
</head>
<body>
  <h2>Sensor Feedback Over Time</h2>
  <h3 id="meta-info" style="text-align:center; margin-top: 0; font-weight: normal; color: #555;"></h3>

  <svg></svg>
  <div class="tooltip"></div>

  <script>
const data = DATA_PLACEHOLDER;


console.log(data.map(d => d.time));



    const userId = USER_ID_PLACEHOLDER; //
    const sensorType = SENSOR_TYPE_PLACEHOLDER;

    document.getElementById("meta-info").textContent = `User ID: ${userId} | Sensor: ${sensorType}`;
const parseTime = d3.utcParse("%Y-%m-%dT%H:%M:%S.%LZ");
const formatTime = d3.timeFormat("%Y-%m-%d %H:%M");
    data.forEach(d => d.parsedTime = parseTime(d.time));

    const svg = d3.select("svg");
const margin = { top: 40, right: 200, bottom: 60, left: 100 };
    const width = svg.node().clientWidth - margin.left - margin.right;
    const height = svg.node().clientHeight - margin.top - margin.bottom;
// Define a clip path to constrain drawing inside the chart area
svg.append("defs").append("clipPath")
  .attr("id", "clip")
  .append("rect")
  .attr("x", 0)
  .attr("y", 0)
  .attr("width", width)
  .attr("height", height);

// Main container group
const g = svg.append("g")
  .attr("transform", `translate(${margin.left},${margin.top})`);

// This group will be clipped — for line and circles only
const dataLayer = g.append("g")
  .attr("clip-path", "url(#clip)");


    const x = d3.scaleTime()
      .domain(d3.extent(data, d => d.parsedTime))
      .range([20, width]);

    const y = d3.scaleLinear()
    .domain([
        (() => {
            const minVal = d3.min(data, d => d.value);
            return minVal === 0 ? 0 : minVal - 10;
        })(),
        d3.max(data, d => d.value) + 10
    ])
    .nice()
    .range([height, 0]);

    // Intensity color scale mapping 0-255 to a color gradient
    const intensityThresholds = [20, 50, 100, 150, 200, 230, 255];
    const intensityColors = [
      "#fceabb",  // 0–20 → very light yellow
      "#f8c156",  // 21–50 → light orange
      "#f59e42",  // 51–100 → orange
      "#ec5e34",  // 101–150 → red-orange
      "#cd2e3a",  // 151–200 → red
      "#8e063b",  // 201–230 → dark red
      "#3b0a45"   // 231–255 → very dark purple
    ];
    const color = d3.scaleThreshold()
      .domain(intensityThresholds)
      .range(intensityColors);

    const maxPulses = d3.max(data, d => d.pulses || 0) || 1;

    const radius = d3.scaleSqrt()
    .domain([0, maxPulses])
    .range([4, 14]);

    const tooltip = d3.select(".tooltip");

const xAxis = d3.axisBottom(x).ticks(6).tickFormat(formatTime);

const xAxisG = g.append("g")
  .attr("class", "axis x-axis")
  .attr("transform", `translate(0,${height})`)
  .call(xAxis);

    g.append("g")
      .attr("class", "axis y-axis grid")
      .call(
        d3.axisLeft(y)
          .ticks(6)
          .tickSize(-width)
      );

    // Line generator
    const line = d3.line()
      .x(d => x(d.parsedTime))
      .y(d => y(d.value))
      .curve(d3.curveMonotoneX);

        // Group by minute and pick one alert per minute, or fallback to any point in that minute
    const bucketedData = d3.groups(data, d => d3.timeMinute(d.parsedTime));
    const reducedData = bucketedData.map(([minute, group]) =>
    group.find(d => d.alert_type) || group[0]
    );
    // Draw animated line using full data for smooth curve
const linePath = dataLayer.append("path")
      .datum(data)
      .attr("fill", "none")
      .attr("stroke", "#4682B4")
      .attr("stroke-width", 2)
      .attr("d", line);

    const totalLength = linePath.node().getTotalLength();

    linePath
      .attr("stroke-dasharray", totalLength + " " + totalLength)
      .attr("stroke-dashoffset", totalLength)
      .transition()
      .duration(2000)
      .ease(d3.easeLinear)
      .attr("stroke-dashoffset", 0);

    // Feedback circles with animation
dataLayer.selectAll("circle")
      .data(reducedData.filter(d => d.alert_type))
      .enter().append("circle")
      .attr("cx", d => x(d.parsedTime))
      .attr("cy", d => y(d.value))
      .attr("r", 0)
      .attr("fill", d => color(d.intensity))
      .attr("stroke", "#333")
      .attr("opacity", 0)
      .transition()
      .duration(1000)
      .delay((d, i) => i * 250)
      .attr("r", d => radius(d.pulses))
      .attr("opacity", 1);

    // Re-select for interactivity
dataLayer.selectAll("circle")
      .on("mouseover", function (event, d) {
        tooltip
        .style("transform", "translateY(-10px)")
        .transition()
        .duration(200)
        .style("opacity", 1)
        .style("transform", "translateY(0px)");
    tooltip.html(
            `<strong>Time:</strong> ${formatTime(d.parsedTime)}<br>
            <strong>Value:</strong> ${d.value}<br>
            <strong>Intensity:</strong> ${d.intensity}<br>
            <strong>Pulses:</strong> ${d.pulses}<br>
            <strong>Duration:</strong> ${d.duration || 0} ms<br>
            <strong>Interval:</strong> ${d.interval || 0} ms`
        )
          .style("left", (event.pageX + 10) + "px")
          .style("top", (event.pageY - 30) + "px");

        d3.select(this)
          .transition()
          .duration(150)
          .attr("r", radius(d.pulses) * 1.3);
      })
      .on("mouseout", function (event, d) {
        tooltip.transition().duration(200).style("opacity", 0);
        d3.select(this)
          .transition()
          .duration(200)
        .attr("r", radius(d.pulses));
      });

    // Legend
    const legend = svg.append("g")
      .attr("class", "legend")
      .attr("transform", `translate(${width + margin.left + 20},${margin.top})`);

    legend.append("text").text("Intensity (Color)").attr("font-weight", "bold");

    // Display intensity legend with ranges
    const legendThresholds = [0, ...intensityThresholds];
    legendThresholds.forEach((v, i) => {
      if (i < intensityColors.length) {
        const rangeEnd = intensityThresholds[i] ?? 255;
        const rangeLabel = `${v}–${rangeEnd}`;

        legend.append("rect")
          .attr("x", 0)
          .attr("y", 20 + i * 14)
          .attr("width", 20)
          .attr("height", 12)
          .attr("fill", intensityColors[i]);

        legend.append("text")
          .attr("x", 30)
          .attr("y", 30 + i * 14)
          .attr("font-size", "11px")
          .text(rangeLabel);
      }
    });

    legend.append("text").text("Pulses (Size)").attr("y", 130).attr("font-weight", "bold");
const pulseValues = [2, 4, 6, 8, 10];
let currentY = 150; // starting y-position
const pulsePadding = 6; // desired gap between circles
pulseValues.forEach((v, i) => {
  const r = radius(v);

  legend.append("circle")
    .attr("cx", 10)
    .attr("cy", currentY + r)
    .attr("r", r)
    .attr("fill", "#999");

  legend.append("text")
    .attr("x", 30)
    .attr("y", currentY + r + 4) // text slightly below circle center
    .text(v);

  currentY += 2 * r + pulsePadding; // move down for next circle
});

const zoom = d3.zoom()
  .scaleExtent([1, 100]) // Zoom in/out limits
  .translateExtent([[0, 0], [width, height]]) // Pan bounds
  .extent([[0, 0], [width, height]])
  .on("zoom", zoomed);

svg.call(zoom);

// Prevent zoom reset on double-click
svg.on("dblclick.zoom", null);

function zoomed(event) {
  const transform = event.transform;
  const zx = transform.rescaleX(x);

  // Update the X axis
  xAxisG.call(xAxis.scale(zx));

  // Redraw line with new x-scale using same curve and full data
  const lineWithZoom = d3.line()
    .x(d => zx(d.parsedTime))
    .y(d => y(d.value))
    .curve(d3.curveMonotoneX);

  linePath.datum(data).attr("d", lineWithZoom);

  // Update circles' x position (select from dataLayer, not g)
  dataLayer.selectAll("circle")
    .attr("cx", d => zx(d.parsedTime));
}
  </script>
</body>
</html>
